{
  pkgs,
  lib,
  config,
  inputs,
  ...
}: let
  pkgs-unstable = import inputs.nixpkgs-unstable {
    inherit (pkgs) system;
    config = pkgs.config;
  };
  mcp-config = inputs.mcp-servers.lib.mkConfig pkgs-unstable {
    format = "json";
    fileName = ".mcp.json";

    programs = {
      memory = {
        enable = true;
        env = {
          "MEMORY_FILE_PATH" = "\${MEMORY_FILE_PATH}";
        };
      };
      sequential-thinking.enable = true;
    };

    settings.servers = {
      language-server = {
        command = "mcp-language-server";
        args = ["--workspace" "." "--lsp" "rust-analyzer"];
      };
    };
  };

  # Prepare SQLx database for compile-time verification
  sqlx-db =
    pkgs.runCommand "sqlx-db-prepare" {
      nativeBuildInputs = with pkgs; [sqlx-cli sqlite];
    } ''
      mkdir -p $out
      export DATABASE_URL=sqlite:$out/db.sqlite3

      # Create database and run migrations
      sqlx database create
      sqlx migrate run --source ${./migrations}
    '';

  # Define the lilvault package
  lilvault = pkgs.rustPlatform.buildRustPackage {
    pname = "lilvault";
    version = "0.1.0";

    src = lib.cleanSource ./.;

    cargoLock = {
      lockFile = ./Cargo.lock;
    };

    nativeBuildInputs = with pkgs; [
      pkg-config
      sqlx-cli
    ];

    buildInputs = with pkgs; [
      sqlite
      openssl
    ];

    # Set up database for SQLx compile-time verification
    preBuild = ''
      export DATABASE_URL=sqlite:${sqlx-db}/db.sqlite3
    '';

    # Skip tests in Nix build (tests require interactive terminal features)
    doCheck = false;

    meta = with lib; {
      description = "A secure, encrypted secrets management system for homelabs";
      homepage = "https://github.com/yourusername/lilvault";
      license = with licenses; [mit asl20];
      maintainers = [];
      mainProgram = "lilvault";
    };
  };
in {
  languages.rust = {
    enable = true;
    channel = "stable";
    components = ["rustc" "cargo" "clippy" "rustfmt" "rust-analyzer" "llvm-tools-preview"];
  };

  packages = [
    pkgs-unstable.claude-code
    pkgs.rage
    pkgs.alejandra
    pkgs.treefmt
    pkgs.nil
    pkgs.sqlite
    pkgs.sqlx-cli
    inputs.my-configs.packages.${pkgs.system}.mcp-language-server
  ];

  # Git hooks for code quality
  git-hooks = {
    hooks = {
      # Tree formatting (formats all files)
      treefmt = {
        enable = true;
        description = "Format code with treefmt";
      };

      # Rust linting
      clippy = {
        enable = true;
        description = "Lint Rust code with clippy";
        settings = {
          denyWarnings = true;
        };
      };

      # General code quality
      check-merge-conflicts.enable = true;
      check-added-large-files.enable = true;
      check-toml.enable = true;
      check-yaml.enable = true;
      end-of-file-fixer.enable = true;
      trim-trailing-whitespace.enable = true;
    };
  };

  # Development scripts and tools
  scripts = {
    dump-schema = {
      exec = ''
                echo "ðŸ” Generating schema.sql from current database state..."

                # Create temporary database
                TEMP_DB="temp_schema_dump.db"
                rm -f "$TEMP_DB"

                # Create database directory
                mkdir -p db

                # Create a temporary database and apply migrations
                echo "ðŸ“ Creating temporary database with migrations..."
                echo "temp-password" > /tmp/temp_password
                DATABASE_URL="sqlite:$TEMP_DB" cargo run -- --database "$TEMP_DB" init --name "schema-dump" --password-file /tmp/temp_password > /dev/null 2>&1
                rm -f /tmp/temp_password

                # Dump the schema using sqlite3
                echo "ðŸ“¤ Dumping schema..."
                SCHEMA=$(sqlite3 "$TEMP_DB" ".schema")

                # Generate schema.sql with header
                cat > db/schema.sql << EOF
        -- This file is auto-generated from the current database schema.
        -- Do not edit this file directly. Instead, create a new migration.
        --
        -- Generated at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        -- Database version: (determined by migration files in migrations/)
        --
        -- To regenerate this file, run:
        --   dump-schema

        $SCHEMA
        EOF

                # Show summary
                echo "âœ… Schema dumped to db/schema.sql"
                echo "ðŸ“Š Current schema includes:"

                # List tables
                sqlite3 "$TEMP_DB" ".tables" | tr ' ' '\n' | grep -v '^$' | sed 's/^/   - /'

                # Clean up
                rm -f "$TEMP_DB"

                echo "ðŸŽ‰ Schema dump complete!"
      '';
      description = "Generate db/schema.sql from current migrations (like Rails)";
    };
  };

  # Setup MCP configs
  enterShell = ''
    export MEMORY_FILE_PATH=$(pwd)/.claude/memory.json
    ln -sf ${mcp-config} .mcp.json

    # Generate initial schema.sql if it doesn't exist
    if [ ! -f db/schema.sql ]; then
      echo "ðŸ“‹ Generating initial schema.sql..."
      dump-schema
    fi
  '';

  # Export the lilvault package so other flakes can reference it
  outputs = {
    packages = {
      lilvault = lilvault;
      default = lilvault;
    };
  };
}
